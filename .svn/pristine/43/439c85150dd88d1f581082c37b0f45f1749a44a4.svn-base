################################################################################
#                                                                              #
# wrapper.py - A python wrapper for read_ppm and e3d using subprocesses.       #
#                                                                              #
# (c) 2016 Luke Siemens                                                        #
#                                                                              #
################################################################################

"""
wrapper.py

wrapper is a Python module for reading FVandMoms48-xxxx.bob*** files.
This module uses python subprocesses to wrap the comand line tools read_ppm and
e3d.
"""

__all__ = ["Wrapper", "ReadPPMWarning", "E3DWarning"]

import subprocess
import warnings
import numpy
import os

try:
    _DEVNULL = subprocess.DEVNULL
except AttributeError:
    _DEVNULL = open(os.devnull, "w")

class Wrapper:
    """ 
    The Wrapper class provides a python interface for interacting with the
    moments data produced by the PPM fluid simulation code. This class interacts
    with the moments data saved in FVandMoms47-xxxx.bob*** files using the read_ppm
    and e3d command line tools.
    
    Attributes
    ----------
    dir : string
        Path to directory where e3d and read_ppm should run.
    debug : integer
        Debug level. If debug > 0 then output from read_ppm and e3d is piped to stdout.
        If debug > 1 then the debug level of e3d is set to "Wrapper.debug - 1"
    """
    
    debug = 0
    
    def __init__(self, dir="./"):
        """ 
        Initalize Wrapper class.
        
        Parameters
        ----------
        dir : string, optional
            Path to directory where e3d and read_ppm should run.
        """
        
        self.dir = dir
    
        self._dir_read_ppm = None
        self._dir_e3d = None
        
        self._read_ppm_in = None
        
        self._outfile = None
        self._isdump = False
        self._xresolution, self._yresolution, self._zresolution = None, None, None
        self._xmax, self._ymax, self._zmax = None, None, None
        self._bob_variables = []
        self._recent_files = []

    def __eq__(self, other):
        if isinstance(other, Wrapper):
            if self._read_ppm_in == other._read_ppm_in:
                return True
        return False
    
    def __ne__(self, other):
        return not self.__eq__(other)
        
    def read_radprof(self, file):
        """ 
        Read radprof file. Returns a tuple of numpy arrays.
        
        Parameters
        ----------
        file : string
            Path to the radprof file.
        Returns
        -------
        radius : numpy.array
            Radial coordinates.
        mean : numpy.array
            Mean radial profile of field.
        dispersion : numpy.array
            Dispersion of radial profile.
        minimum : numpy.array
            Minimum radial profile of field.
        maximum : numpy.array
            Maximum radial profile of filed.
        """

        dir = os.path.abspath(self.dir) + "/"

        if os.path.abspath(dir + file) not in self._recent_files:
            e3d_warning("The file: \"" + file + "\" is not associated with this instance.")

        raw_data = numpy.genfromtxt(dir + file, skip_header=1)
        return raw_data[:, [1,2,4,5]]
    
    def read_bof(self, file):
        """ 
        Read bof file.
        
        Parameters
        ----------
        file : string
            Path to the bof file.
        Returns
        -------
        data : numpy.array
            numpy array with shape (x resolution, y resolution, z resolution).
        """

        dir = os.path.abspath(self.dir) + "/"

        if os.path.abspath(dir + file) not in self._recent_files:
            e3d_warning("The file: \"" + file + "\" is not associated with this instance.")
        
        raw_data = numpy.fromfile(dir + file, dtype=numpy.float32)
        return raw_data.reshape((self._xresolution, self._yresolution, self._zresolution), order="F")
        
    def generate_bof(self, field, formulas="\n"):
        """ 
        Use e3d to generate a bof file of the given field from the dumpfile.
        
        Parameters
        ----------
        field : string
            Name of the field to output, it may be a raw data field or a computed
            field as defined by the argument formulas.
        formulas : string, optional
            A string defining computed fields to be generated by e3d. The default
            is "\\n"
        """

        if field is None:
            raise TypeError("field must be a string")

        self.process_dumpfile("bof", field, formulas)
    
    def generate_radprof(self, field, formulas="\n"):
        """ 
        Use e3d to generate a radprof file of the given field from the dumpfile.
        
        Parameters
        ----------
        field : string
            Name of the field to output, it may be a raw data field or a computed
            field as defined by the argument formulas.
        formulas : string, optional
            A string defining computed fields to be generated by e3d. The default
            is "\\n"
        """
        
        if field is None:
            raise TypeError("field must be a string")

        self.process_dumpfile("radprof", field, formulas)

        dir = self._prepare_dir()

        if os.path.isfile(dir + self._outfile[:-3] + str(field) + ".radprof.plt"):
            os.remove(dir + self._outfile[:-3] + str(field) + ".radprof.plt")

    def process_dumpfile(self, output, field=None, formulas="\n", **kwargs):
        """ 
        Use e3d to process dumpfile. The generated input.e3d file always includes
        the dumpfile and output statements. If field is not None the field statement
        will also be included. Aditional statmets may be added using key value
        pairs in the kwargs.
        
        Parameters
        ----------
        output : string
            Output type to produce.
        field : string, optional
            Name of the field to output, it may be a raw data field or a computed
            field as defined by the argument formulas. If None then no field
            statement is used. The default is None
        formulas : string, optional
            A string defining computed fields to be generated by e3d. The default
            is "\\n"
        kwargs : dict, optional
            A dictonary of statement tokens and associated arguments to be added
            to the input.e3d file.
        """

        e3d_arguments = {"field":field}

        kwargs.update(e3d_arguments)

        dir = self._prepare_dir()

        if os.path.isfile(dir + self._outfile[:-3] + str(field) + "." + str(output)):
            os.remove(dir + self._outfile[:-3] + str(field) + "." + str(output))

        if self.debug > 0:
            stdout = None
            stderr = subprocess.STDOUT
        else:
            stdout = _DEVNULL
            stderr = _DEVNULL
        
        self._run_e3d(output, stdout=stdout, stderr=stderr, formulas=formulas, **kwargs)

        self._recent_files.append(os.path.abspath(dir + self._outfile[:-3] + str(field) + "." + str(output)))

    def process_bobfiles(self, bobfiles=None, outfile=None, force_clean=False):
        """ 
        Use read_ppm to process bob files. If outfile begins with "bofs:" one
        .bof file will be produced for every variable defined with the readvars
        statements. If outfile does not begin with "bofs:" then one dumpfile
        compatible with e3d will be produced.

        Parameters
        ----------
        bobfiles : string, optional
            Path to the first bob file. If bobfiles is None then the path currently
            defined in the loaded read_ppm file will be used. The default is None.
        outfile : string, optional
            Name of the output generated by read_ppm. If it does not begin with
            "bofs:" then a dumpfile will be produced, otherwise .bof files will
            be produced.
        force_clean : bool, optional
            Force removal and recomputing of read_ppm files. The default is False.
        """
        
        read_ppm_arguments = {}
        
        if bobfiles is not None:
            if (bobfiles[0] not in ["\"", "\'"]) and (bobfiles[0] not in ["\"", "\'"]):
                bobfiles = "\"" + bobfiles + "\""
            read_ppm_arguments["file"] = bobfiles
            
        if outfile is not None:
            read_ppm_arguments["outfile"] = outfile

        if self._read_ppm_in is None:
            raise RuntimeError("No read_ppm.in file loaded.")
        
        if read_ppm_arguments:
            self.update_read_ppm_in(**read_ppm_arguments)
            
        dir_read_ppm = ""
        if self._dir_read_ppm is not None:
            dir_read_ppm = os.path.abspath(self._dir_read_ppm) + "/"
            
        dir = self._prepare_dir()

        if (self._reprocess_bobfiles()) or force_clean:
            self._reset_class_instance()

            if self._outfile is not None:
                with open(dir + "read_ppm_" + self._outfile + ".in", "w") as fout:
                    fout.write(self._read_ppm_in)
            
            with open(dir + "read_ppm.in", "w") as fout:
                fout.write(self._read_ppm_in)
            
            if self.debug > 0:
                stdout = None
                stderr = subprocess.STDOUT
            else:
                stdout = _DEVNULL
                stderr = _DEVNULL
            
            read_ppm_task = subprocess.Popen([dir_read_ppm + "read_ppm"], cwd=dir, stdout=stdout, stderr=stderr)
            read_ppm_task.wait()
            
        self._initalize_class_variables()
        
    def update_read_ppm_in(self, statement_type=None, **kwargs):
        """ 
        Update statments in read_ppm.in file using key value pairs in the kwargs.
        If statemtn_type is None keywords in kwargs are assumed to be statment
        tokens, else if statement_type is "field" or "field8" then the keyword is
        assumed to be the first argument of the statment.
        
        Parameters
        ----------
        statement_type : string, optional
            If statement_type is None, then kwargs defines the statement token and
            arguments, if statement_type is "field" or "field8" then kwargs defines
            the arguments of the field/field8 statement. The default is None.
        kwargs : dict, optional
            A dictonary of statement tokens and associated arguments. If
            statement_type is not None then kwargs is the first and associated
            remaining arguments to the field/field8 statement.
        """
        
        self._read_ppm_in = _update_read_ppm_in(self._read_ppm_in, statement_type=statement_type, **kwargs)
        self._initalize_class_variables()
        
    def load_read_ppm_in(self, fname):
        """ 
        Load read_ppm.in from file.
        
        Parameters
        ----------
        fname : string
            Path to read_ppm.in file to load.
        """
        
        with open(fname, "r") as fin:
            self._read_ppm_in = fin.read()
        self._initalize_class_variables()
           
    def set_read_ppm_in(self, read_ppm_in=None):
        """ 
        Set read_ppm.in file.
        
        Parameters
        ----------
        read_ppm_in : string, optional
            Contents of read_ppm.in file. The default is None.
        """
        
        self._read_ppm_in = read_ppm_in
        self._initalize_class_variables()
        
    def get_read_ppm_in(self):
        """ 
        Get read_ppm.in file.
        
        Returns
        -------
        read_ppm_in : string
            Contents of read_ppm.in file.
        """
        return self._read_ppm_in
            
    def set_tool_paths(self, dir_read_ppm=None, dir_e3d=None):
        """ 
        Set path to command line tools e3d and read_ppm. Set the path to None
        if they are in the system path.
        
        Parameters
        ----------
        dir_read_ppm : string, optional
            The path to read_ppm, set to None if read_ppm is in the system Path.
            The default is None.
        dir_e3d : string, optional
            The path to e3d, set to None if read_ppm is in the system Path.  The
            default is None.
        """

        self._dir_read_ppm = dir_read_ppm
        self._dir_e3d = dir_e3d
        
    def get_tool_path(self):
        """ 
        get path to command line tools e3d and read_ppm. The path is set to None
        if they are in the system path.
        
        Returns
        -------
        dir_read_ppm : string
            The path to read_ppm, it is set to None if read_ppm is in the system Path.
        dir_e3d : string
            The path to e3d, it is set to None if read_ppm is in the system Path.
        """

        return self._dir_read_ppm, self._dir_e3d

    def _run_e3d(self, output, stdout=None, stderr=None, formulas="\n", **kwargs):
        """ 
        Run e3d. The generated input.e3d file always includes the dumpfile and
        output statements. Aditional statmets may be added using key value pairs
        in the kwargs.
        
        Parameters
        ----------
        output : string
            Output type to produce.
        stdout : file, optional
            Standard output file handle. The default is None.
        stdin : file, optional
            Standard error file handle. The default is None.
        formulas : string, optional
            A string defining computed fields to be generated by e3d. The default
            is "\\n"
        kwargs : dict, optional
            A dictonary of statement tokens and associated arguments to be added
            to the input.e3d file.
            
        Returns
        -------
        output : tuple
            A tuple contianing the stdout and stderr.
        """

        if (self._outfile is None) or (not self._isdump):
            raise IOError("This object has no associated dumpfile.")
        
        e3d_arguments = {"dumpfile":"\"" + self._outfile + "\"", "output":output}

        if self.debug > 1:
            e3d_arguments["setconst  debug="] = self.debug - 1

        kwargs.update(e3d_arguments)

        inputfile = "\n"
        for keyword in kwargs:
            if kwargs[keyword] is not None:
                if (keyword.startswith("setconst")) and (keyword[-1] == "="):
                    inputfile = inputfile + keyword + str(kwargs[keyword]) + "\n"
                else:
                    inputfile = inputfile + keyword.ljust(10) + str(kwargs[keyword]) + "\n"

        dir_e3d = ""
        if self._dir_e3d is not None:
            dir_e3d = os.path.abspath(self._dir_e3d) + "/"
            
        dir = self._prepare_dir()

        with open(dir + "input.e3d", "w") as fout:
            fout.write(inputfile)
            
        with open(dir + "formulas.e3d", "w") as fout:
            fout.write(formulas)
        
        e3d_task = subprocess.Popen([dir_e3d + "e3d"], cwd=dir, stdout=stdout, stderr=stderr)
        return e3d_task.communicate()

    def _prepare_dir(self):
        dir = os.path.abspath(self.dir) + "/"
        
        if not os.path.isdir(dir):
            os.makedirs(dir)
        
        return dir

    def _initalize_class_variables(self):
        """ 
        Initalize class varaibles based on the current read_ppm.in file.
        """
        
        self._find_resolution()

        outfile = ""
        isdump = True
        readvars = ""

        read_ppm_in = self._read_ppm_in.split("\n")        
        for line in read_ppm_in:
            line = line.split(None, 1)
            if len(line) > 1:
                if line[0] == "outfile":
                    outfile = line[1].strip()
                    if outfile.startswith("bofs:"):
                        isdump = False
                        outfile = outfile[5:]
                if line[0] == "readvars":
                    readvars = line[1].strip().replace("\"", "").replace("\'", "").split()
        self._bob_variables = readvars
        self._isdump = isdump
        self._outfile = outfile
 
        if not self._isdump:
            dir = os.path.abspath(self.dir) + "/"
            for variable in self._bob_variables:
                self._recent_files.append(os.path.abspath(dir + outfile + "-" + str(variable) + ".bof"))
                
    def _clear_class_variables(self):
        """ 
        Set variables to defaults.
        """
        
        self._outfile = None
        self._isdump = False
        self._xresolution, self._yresolution, self._zresolution = None, None, None        
        self._bob_variables = []
        self._recent_files = []

    def _reset_class_instance(self):
        """ 
        Remove files, and reset variables.
        """

        dir = os.path.abspath(self.dir) + "/"
        
        if os.path.isfile(dir + "read_ppm.in"):
            os.remove(dir + "read_ppm.in")
        
        if self._outfile is not None:
            if os.path.isfile(dir + "read_ppm_" + self._outfile + ".in"):
                os.remove(dir + "read_ppm_" + self._outfile + ".in")

            if os.path.isfile(dir + self._outfile):
                os.remove(dir + self._outfile)

        for file in self._recent_files:
            if os.path.isfile(file):
                os.remove(file)
        
        self._clear_class_variables()
        self._initalize_class_variables()

    def _reprocess_bobfiles(self):
        """ 
        Check if files need to be removed and recomputed.        
        """

        dir = self._prepare_dir()

        file_read_ppm = ""
        if self._outfile is not None:
            if os.path.isfile(dir + "read_ppm_" + self._outfile + ".in"):
                with open(dir + "read_ppm_" + self._outfile + ".in", "r") as fin:
                    file_read_ppm = fin.read()

        if self._read_ppm_in is None:
            raise RuntimeError("No read_ppm.in file loaded.")
                    
        if file_read_ppm.strip() != self._read_ppm_in.strip():
            return True
        
        if self._outfile is not None:
            if self._isdump:
                if not os.path.isfile(dir + self._outfile):
                    return True
            else:
                for var in self._bob_variables:
                    if not os.path.isfile(dir + self._outfile + "-" + var + ".bof"):
                        return True
        
        return False

    def _find_resolution(self):
        """ 
        Find resolution of data and range of axes from read_ppm.in file.
        """
        
        ixyz0, nxyz = [0, 0, 0], [0, 0, 0]
        bsize, nbrk, nfile = {}, {}, {}
        
        read_ppm_in = self._read_ppm_in.split("\n")
        for line in read_ppm_in:
            line = line.split(None, 1)
            if len(line) > 1:
                if line[0] == "ixyz0":
                    line = line[1].split()
                    if len(line) > 2:
                        ixyz0 = [int(line[0]) - 1, int(line[1]) - 1, int(line[2]) - 1]
                elif line[0] == "nxyz":
                    line = line[1].split()
                    if len(line) > 2:
                        nxyz = [int(line[0]), int(line[1]), int(line[2])]
                elif line[0].startswith("bsize"):
                    axis = line[0][-1]
                    line = line[1].split()
                    if len(line) > 0:
                        bsize[axis] = float(line[0])
                elif line[0].startswith("nbrk"):
                    axis = line[0][-1]
                    line = line[1].split()
                    if len(line) > 0:
                        nbrk[axis] = int(line[0])
                elif line[0].startswith("nfile"):
                    axis = line[0][-1]
                    line = line[1].split()
                    if len(line) > 0:
                        nfile[axis] = int(line[0])

        self._xresolution, self._yresolution, self._zresolution = nxyz[0] - ixyz0[0], nxyz[1] - ixyz0[1], nxyz[2] - ixyz0[2]
        self._xmax, self._ymax, self._zmax = bsize["x"]*nbrk["x"]*nfile["x"]/2.0, bsize["y"]*nbrk["y"]*nfile["y"]/2.0, bsize["z"]*nbrk["z"]*nfile["z"]/2.0

def _update_read_ppm_in(read_ppm_in, statement_type=None, **kwargs):
    """ 
    Update statments in read_ppm.in file using key value pairs in the kwargs.
    If statemtn_type is None keywords in kwargs are assumed to be statment
    tokens, else if statement_type is "field" or "field8" then the keyword is
    assumed to be the first argument of the statment.
    
    Parameters
    ----------
    read_ppm_in : string
        The contents of the read_ppm.in file.
    statement_type : string, optional
        If statement_type is None, then kwargs defines the statement token and
        arguments, if statement_type is "field" or "field8" then kwargs defines
        the arguments of the field/field8 statement. The default is None.
    kwargs : dict, optional
        A dictonary of statement tokens and associated arguments. If
        statement_type is not None then kwargs is the first and associated
        remaining arguments to the field/field8 statement.
        
    Returns
    -------
    read_ppm_in : string
        Updated read_ppm.in string.
    """
    
    read_ppm_in = read_ppm_in.split("\n")
    
    new_keyword = []
    for keyword in kwargs:
        isnew = True
        for i, line in enumerate(read_ppm_in):
            line = line.split()
            if statement_type is None:
                if len(line) > 0:
                    if keyword == line[0]:
                        if keyword in ["file", "readvars"]:
                            if (kwargs[keyword][0] not in ["\"", "\'"]) or (kwargs[keyword][-1] not in ["\"", "\'"]):
                                read_ppm_warning(keyword + " argument not in quotations, this may cause unexpected behavior.")
                        read_ppm_in[i] = keyword.ljust(10) + str(kwargs[keyword])
                        isnew = False
            elif statement_type in ["field", "field8"]:
                if len(line) > 1:
                    if (keyword == line[1]) and (line[0] in ["field", "field8"]):
                        read_ppm_in[i] = statement_type.ljust(10) + keyword.ljust(16) + kwargs[keyword]
                        isnew = False

        if isnew:
            new_keyword.append(keyword)
            
    for keyword in new_keyword:
        if statement_type is None:
            if keyword in ["file", "readvars"]:
                if (kwargs[keyword][0] not in ["\"", "\'"]) or (kwargs[keyword][-1] not in ["\"", "\'"]):
                    read_ppm_warning(keyword + " argument not in quotations, this may cause unexpected behavior.")
            read_ppm_in.append(keyword.ljust(10) + str(kwargs[keyword]))
        elif statement_type in ["field", "field8"]:
            read_ppm_in.append(statement_type.ljust(10) + keyword.ljust(16) + kwargs[keyword])

    return "\n".join(read_ppm_in)
    
# define custom warnings
class ReadPPMWarning(UserWarning):
    """ 
    Warnings spesific to interacting with the utility read_ppm.
    """
    
class E3DWarning(UserWarning):
    """ 
    Warnings spesific to interacting with the utility e3d.
    """

def read_ppm_warning(message):
    """ 
    Issue a ReadPPMWarning.
    
    Parameters
    ----------
    message : string
        The warning message.

    """

    warnings.warn(message, ReadPPMWarning, stacklevel=2)

def e3d_warning(message):
    """ 
    Issue an E3DWarning.
    
    Parameters
    ----------
    message : string
        The warning message.
    """

    warnings.warn(message, E3DWarning, stacklevel=2)

# redefine warnings.showwarning so if category is ReadPPMWarning or E3DWarning then
# line set to line before calling warnings.showwarning else all arguments are
# passed to the original warnings.showwarning function
_showwarning = warnings.showwarning
def showwarning(message, category, filename, lineno, file=None, line=None):
    if issubclass(category, ReadPPMWarning) or issubclass(category, E3DWarning):
        _showwarning(message, category, filename, lineno, line="")
    else:
        _showwarning(message, category, filename, lineno, line=line)
showwarning.__doc__ = _showwarning.__doc__ # keep original docstring
warnings.showwarning = showwarning
